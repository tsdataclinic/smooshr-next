"""Entry point for the API server"""
import logging
from contextlib import contextmanager
from datetime import datetime
from typing import Any, Generator

from fastapi import Depends, FastAPI, HTTPException, Security
from fastapi.middleware.cors import CORSMiddleware
from fastapi.routing import APIRoute
from fastapi_azure_auth import B2CMultiTenantAuthorizationCodeBearer
from fastapi_azure_auth.user import User as AzureUser
from pydantic import AnyHttpUrl, Field
from pydantic_settings import BaseSettings, SettingsConfigDict
from sqlalchemy.orm import Session

from server.database import SessionLocal
from server.models.user.db_model import DBUser
from server.models.user.schemas import User
from server.models.workflow.db_model import DBWorkflow
from server.models.workflow.schemas import (
    BaseWorkflow,
    FullWorkflow,
    WorkflowCreate,
    WorkflowUpdate,
)

LOG = logging.getLogger(__name__)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelprefix)s %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)


class Settings(BaseSettings):
    """Core configurations for the API server"""

    BACKEND_CORS_ORIGINS: list[str | AnyHttpUrl] = ["http://localhost:5173"]
    AZURE_APP_CLIENT_ID: str = Field(default="")
    AZURE_OPENAPI_CLIENT_ID: str = Field(default="")
    AZURE_DOMAIN_NAME: str = Field(default="")
    AZURE_POLICY_AUTH_NAME: str = Field(default="")
    AZURE_B2C_SCOPES: str = Field(default="")

    model_config: SettingsConfigDict = SettingsConfigDict(
        env_file=".env.server", case_sensitive=True
    )


def custom_generate_unique_id(route: APIRoute) -> str:
    """Change the unique id that FastAPI gives each function so it's formatted
    as [apiTag]-[routeName]. This makes our autogenerated TypeScript functions
    a lot cleaner.
    """
    return f"{route.name}"


settings = Settings()

app = FastAPI(
    title="Smooshr2 API",
    generate_unique_id_function=custom_generate_unique_id,
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

azure_scheme = B2CMultiTenantAuthorizationCodeBearer(
    app_client_id=settings.AZURE_APP_CLIENT_ID,
    scopes={
        f"https://{settings.AZURE_B2C_SCOPES}": "API Scope",
    },
    openid_config_url=(
        f"https://{settings.AZURE_DOMAIN_NAME}.b2clogin.com/{settings.AZURE_DOMAIN_NAME}"
        f".onmicrosoft.com/{settings.AZURE_POLICY_AUTH_NAME}/v2.0/.well-known/"
        f"openid-configuration"
    ),
    openapi_authorization_url=(
        f"https://{settings.AZURE_DOMAIN_NAME}.b2clogin.com/{settings.AZURE_DOMAIN_NAME}"
        f".onmicrosoft.com/{settings.AZURE_POLICY_AUTH_NAME}/oauth2/v2.0/token"
    ),
    validate_iss=False,
)


@contextmanager
def _commit_or_rollback(session):
    # Helper function to commit or rollback a session
    try:
        yield
        session.commit()
    except:
        session.rollback()
        raise


def get_session() -> Generator[Session, Any, None]:
    """Get a DB session"""
    session = SessionLocal()
    try:
        yield session
    finally:
        session.close()


def get_current_user(
    azure_user: AzureUser = Depends(azure_scheme),
    session: Session = Depends(get_session),
) -> DBUser:
    """This function returns the currently authenticated user."""
    # check if the azure user exists in our database already
    user_id: str = azure_user.claims.get("oid", "")
    db_user = session.get(DBUser, user_id)
    if db_user:
        return db_user

    # user doesn't exist yet, so create the user
    token = azure_user.claims
    new_db_user = DBUser(
        id=user_id,
        email=token.get("emails", ["no_email"])[0],
        identity_provider=token.get("idp", "local"),
        family_name=token.get("family_name", ""),
        given_name=token.get("given_name", ""),
    )
    session.add(new_db_user)
    session.commit()
    session.refresh(new_db_user)
    return new_db_user


@app.get(
    "/api/users/self",
    dependencies=[Security(azure_scheme)],
    tags=["users"],
)
def get_self_user(user: DBUser = Depends(get_current_user)) -> User:
    """Get the currently signed in user"""
    return user


@app.get("/api/workflows/{workflow_id}", tags=["workflows"])
def get_workflow(
    workflow_id: int, session: Session = Depends(get_session)
) -> FullWorkflow:
    """Get a workflow by ID"""
    # TODO - This should be updated to only return workflows for
    #        the current user once authentication is implemented.
    db_workflow = session.query(DBWorkflow).filter(DBWorkflow.id == workflow_id).first()
    if not db_workflow:
        raise HTTPException(status_code=404, detail="Workflow not found")
    return FullWorkflow.model_validate(db_workflow)


@app.get("/api/workflows", tags=["workflows"])
def get_workflows(session: Session = Depends(get_session)) -> list[BaseWorkflow]:
    """Get all workflows for the current user."""
    # TODO - This should be updated to only return workflows for
    #        the current user once authentication is implemented.
    db_workflows = session.query(DBWorkflow).all()
    return [BaseWorkflow.model_validate(db_workflow) for db_workflow in db_workflows]


@app.post("/api/workflows", tags=["workflows"])
def create_workflow(
    workflow_data: WorkflowCreate,
    user: DBUser = Depends(get_current_user),
    session: Session = Depends(get_session),
) -> FullWorkflow:
    """Create a new workflow"""
    db_workflow = DBWorkflow(
        **workflow_data.model_dump(),
        owner=user.id,
        created_date=datetime.now(),
    )
    with _commit_or_rollback(session):
        session.add(db_workflow)
    session.refresh(db_workflow)

    return FullWorkflow.model_validate(db_workflow)


@app.put("/workflows/{workflow_id}", tags=["workflows"])
def update_workflow(
    workflow_id: int,
    workflow_data: WorkflowUpdate,
    session: Session = Depends(get_session),
) -> FullWorkflow:
    """Update a workflow by ID"""
    # TODO - This should be updated to only allow the owner of the workflow
    #        or admins to update it once authentication is implemented.
    db_workflow = session.query(DBWorkflow).filter(DBWorkflow.id == workflow_id).first()
    if not db_workflow:
        raise HTTPException(status_code=404, detail="Workflow not found")
    for key, value in workflow_data.model_dump().items():
        setattr(db_workflow, key, value)
    session.commit()
    session.refresh(db_workflow)
    return FullWorkflow.model_validate(db_workflow)


@app.delete("/api/workflows/{workflow_id}", tags=["workflows"])
def delete_workflow(workflow_id: int, session: Session = Depends(get_session)):
    """Delete a workflow by ID"""
    # TODO - This should be updated to only allow the owner of the workflow
    #        or admins to delete it once authentication is implemented.
    db_workflow = session.query(DBWorkflow).filter(DBWorkflow.id == workflow_id).first()
    if not db_workflow:
        raise HTTPException(status_code=404, detail="Workflow not found")
    with _commit_or_rollback(session):
        session.delete(db_workflow)
    return {"message": "Workflow deleted"}
